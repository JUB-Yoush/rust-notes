# Chapter 4: Understanding Ownership
- ownership is rust's most unique and defining feature
- it enables rust to make memory safety guarantees without needing a garbage collector
- this chapter is all about how ownership works

# 4.1: What is Ownership?
>Ownership is a discipline for ensuring the safety of Rust programs

## What makes a rust program safe or unsafe
**Safety:**: The Absence of Undefined Behavior 
- lets look at code examples:
```Rust
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    let x = true;
    read(x);
}
```
- nice and safe
- we can make it unsafe by moving the call that uses x before we define it

```Rust 
fn read(y: bool) {
    if y {
        println!("y is true!");
    }
}

fn main() {
    read(x); // oh no! x isn't defined!
    let x = true;
}
```
- read expects a bool value, but there is no value bound to x yet
- in other languages, this would throw an error
- interpreted langs (py, js) need to check if each variable is given a value before
- these checks add up and slow programs down, rust tries to make binaries as fast as possible and avoids these checks.
- rust checks a compile time to ensure variables have the expected values.
- this code will produce the following error:
```
error[E0425]: cannot find value `x` in this scope
 --> src/main.rs:8:10
  |
8 |     read(x); // oh no! x isn't defined!
  |          ^ not found in this scope

```
- You could assume why it would be important for rust to make sure vars are defined before use.
- but to help understand exactly how important it is, let's explore if **Rust didn't reject unsafe programs from compiling**
- let's consider how the safe version is compiled. rust produces the following x86 AMS for the main function on a safe program

```S
main:
    ; ...
    mov     edi, 1
    call    read
    ; ...
```
- for those who aren't familiar with assembly (like me):
- this code will:
  - move the number 1, representing ``true``, into a "register" (a kind of assembly variable) called edi
  - Call the ``read``  function, which expects its first argument ``y`` to be in the ``edi`` register.

this would be the asm of the unsafe version 
```S
main:
    ; ...
    call    read
    mov     edi, 1    ; mov is after call
    ; ...
```
- read will expect edi to be a boolean, but it could be whatever man 
- this causes undefined behavior
- rusts foundational goal is to ensure no unidentified behavior get's compiled 
- that's what safety in rust is referring to 
>70% of reported security vulnerabilities in low-level systems are caused by memory corruption, which is one form of undefined behavior.
- also checking at compile time instead of run time ensures that bugs don't reach production, as well as fewer runtime checks for those bugs

## Ownership as a Discipline for Memory Safety
- safety is not having undefined behavior
- ownership is about safety
- ownership prevents undefined behavior
- let's focus on one category: **operations on memory**
- Memory is the space where data is stored during the execution of a program.
- how does memory work in a rust program?

## Variables Live in the stack
-  