# Chapter 3.1: Common Programming Concepts
- In this chapter we will learn:
    - concepts that appear in almost every programming language, and how they work in rust.
        - variables 
        - basic types 
        - functions 
        - comments
        - control flow

## Keywords
 - Like most languages, rust has a set of keywords that are reserved for use by the language only. You **cannot use keywords as the names of functions or variables**

## Variables and Mutability
- In rust, variables are **immutable** by default.
- This is the languages way of encouraging you to take advantage of the safety and easy concurrency that Rust offers.
- Rust generally encourages you to favor immutability.
- Immutable values can't be changed after making them
- consider the following code:
```Rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- we never used the mut keyword on x, so when we go to compile this code
```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```
- the compiler in rust is super cool and friendly and wants to make sure you aren't making your computer explode.

- ``cannot assign twice to immutable variable x`` means you're re-assigning a immutable variable
- if your variable's value is expected to never change and *does*, it can lead to very hard to track errors.
- Rust won't let you write unsafe code 
- to make a variable mutable, use the ``mut`` keyword

```Rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
- the program now compiles yipeee


## Constants
```Rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
- Like non mut variables, constants are assigned a value once and cannot be overwritten, but they aren't the same thing.
- you make consts with the ``const`` keyword, you can't make them mutable
- the type of the value must be annotated.
- constants can be declared in any scope, outside any function.
- consts must also be a constant expression, not somthing that could only be computed at runtime
- the rust naming convention is all caps with underscores in between
- only certain operations can be used when defining constants
- naming hard-coded values as constants can help make your code maintainable and manageable

## Shadowing
- You can declare variables with the same name an existing one
- it's called shadowing
- the shadowed variable overshadows the existing one, the compiler can only see the highest value overshadow.
- the shadowing goes away when you leave the scope in which the shadow was defined in.
```Rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
- this program binds ``x`` to 5
- it then makes a new variable ``x``, that's equal to ``x + 1``, so x is 6
- an **inner scope** is created with curly braces, and x is re-defined to be x * 2
- x was already shadowed to be 6, so x * 2 would be 12
- we leave the inner scope, so the value goes back to being 6
  
```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```
- Shadowing a value isn't like making it mutable, you need to re-define the value every time with the ``let`` keyword each time
- using let lets us make a few transformations on a variable but maintain it's immutability 
- we're also making a new variable when we use ``let``, the compiler forget's about every value that isn't the most recently shadowed
- for example, say we ask a user to show how many spaces they'd want between some text
```Rust
    let spaces = "   ";
    let spaces = spaces.len();
```
- the first spaces variable is a string and the 2nd is a number type 
- this allows us to change the type and abandon the string variable when it's no longer helpful to us

# 3.2 Data Types
- every value in rust is a certain data type, which tells rust what kind of data is in a variable
- rust is a **statically typed** language, meaning the compiler needs to know the types of all variables at compile time.
- the compiler can infer some types based on the entered value, but if just entering a value makes it ambiguous (like a number), you'll need to define it explicitly

```Rust
let guess: u32 = "42".parse().expect("Not a number!");
```
if we don't put the ``: u32``, you'll get an error from lack of type annotation

```
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```
## Scalar Types
- a scalar type represents a single value
- rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters
  
### Integer Types
- An integer is a whole number. We used an integer in ch2, the ``u32``, the u means the number is unsigned, i means a value is signed, the number represents the length of the value, from 8 bit to 128-bit (also arch length but idk what that is)
- signed integers use the two's complement algorithm to manage the negative sign
- the arch sign is a 64-bit int or a 32-bit int depending on your pc cpu
- 